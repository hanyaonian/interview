## Chapter 2 Javascript In HTML

#### <script>
- **async** 即刻下载脚本（仅外部），且不阻塞页面其他动作(如下载资源以及其他脚本加载)，**不保证加载执行顺序**
- **crossorigin** 默认不使用，‘anonymous’文件请求不必设置凭据标志，‘use-credentials’设置凭据标志，标示出站请求会包含
- **defer** 标示脚本（仅外部）延迟加载，文档完全被解析执行后再显示，**defer保证加载执行顺序，实际不一定**，run after domInteractive, before domContentLoaded
- **integrity** 签名比对，用于查看资源内容有无被更改，可用于校验cdn分发的文件有无被恶意篡改
- **type** type为module时才可以使用 export和import

- js文件按顺序加载，前面的解释完毕才能解释下一个（以前遇到的引用顺序问题）。
- css放在body前，js放在body后：老生常谈，不阻塞页面加载渲染了。
- 动态加载脚本：js插入 link rel=‘preload‘ href=’..js‘ 保证动态脚本的优先级


## Chapter 3、4 Some Basic Knowledge

###### 作用域
- let: 块作用域， var: 函数作用域你
- var 声明会被拿到函数或全剧作用域的定吧，位于作用域中所有代码之前（变量提升）
- let不会被作用域提升，所以声明前的区域是’暂时性死区‘；全局作用域声明的let变量不会变成全局变量；let也不能依赖条件声明模式 

// 避免忘了symbol有点点特殊，btw Symbol用的实在实在太少了。。。
let s1 = Symbol('123');
let o = {
	[s1]: 123
}

###### 垃圾回收
- 标记清除法：变量进入上下文时，会被添加一个存在于上下文的标记，当变量离开上下文时，添加一个离开的标记，然后周期性回收带有离开标记的变量。垃圾回收运行时：先标记所有，再移除在上下文上以及被上下文引用的变量的标记，在此之后其他带标记的变量都是要被回收的了。
- 引用计数法：现在比较少浏览器使用这个，因为出现循环引用时，变量永远不会被回收。如构建tiertree时父子互指，就会互相计数永远不正确永远不回收。
- 实际应用：
	1. 解除引用，如各类全局变量、全局属性、事件监听器等
	2. v8会将创建的对象和隐藏类关联起来，用以跟踪它们的属性特征；共享相同隐藏类的对象性能会更好。避免“先创建对象再补充属性”，（好的方式：在构造函数里一次性声明所有属性）可以更好的共享隐藏类。
	3. 闭包引用。例如：定时器里通过闭包引用了变量，变量不会回收；闭包返回的内容如果太大也会造成一定的内存占用。

