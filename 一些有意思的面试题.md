+ 事件循环是JS线程处理的还是浏览器处理的？
	- 浏览器处理的。在nodejs上又是别的事件处理机制。 
	> Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现。libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
	> 浏览器中，引用wiki：“Event Loop是一个程序结构，用于等待和发送消息和事件”。有一个专门负责和主线程与其他进程的通信（I/O，请求），event loop线程。

+ 当前任务队列都为空，会怎么做
	- 啥也不干（idle），等到下个任务出现

+ 浏览器里有一些js脚本（a、b、c、d等顺序排列），一些css样式表，问加载执行顺序的相关问题。
	- 如果没有加defer，async，都是按顺序进行加载、执行，上一个没加载前是不会加载下一个的；且js与css未加载完不会进行页面渲染。css放头部，js放尾部可以最快的渲染出页面内容。（红宝书第二章）

+ ['1', '2', '3'].map(parseInt) what & why ?
	- parseInt: 第一个参数是数字字符，第二个参数radix是表示进制；map func的第一个参数是value，第二个参数是index。因此执行过程实际上是 1 0进制，2 1进制， 3 2进制。超了进制所以是NaN。MDN对parseInt第二个参数的解释：从 2 到 36，表示字符串的基数。
	如果 radix 是 undefined、0或未指定的，JavaScript会假定以下情况：
		1. 如果输入的 string以 "0x"或 "0x"（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被当做十六进制数去解析。
		2. 如果输入的 string以 "0"（0）开头， radix被假定为8（八进制）或10（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。
		3. 如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。
		4. 如果第一个字符不能转换为数字，parseInt会返回 NaN。

+ 列表组件中写 key，其作用是什么？
	- 文档内说明：不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。key不正确出现过什么问题：做vrs的时候，重复下单同一个商品的key一致，ui渲染出现紊乱，因为识别key相同导致ui未更新，实际上内容是有更新的。
	- https://juejin.cn/post/6844904113587634184

+ 说出六种以上判断变量类型的方式
	1. typeof
	````
	"undefined" --- 如果这个值未定义
	"string" --- 如果这个值是字符串
	"boolean" --- 如果这个值是布尔类型值
	"number" --- 如果这个值是数值
	"object" --- 如果这个值是对象或者 null(typeof null 是object)
	"function" --- 如果这个值是函数
	"symbol" --- 如果是symbol
	````
	2. instanceof 检测不了基本类型
	3. 通过变量的construct进行判断
	````js
	let a = Symbol(1)
	a.constructor === Symbol //true
	````
	4. Object.prototype.toString.call(), 输出 "[object Object]"之类的
	````
	注意往数组/对象里用莫名其妙的东西做key的时候(不包含null)，都会把这个东西tostring了再做key，实际上就是a['object Object']之类的了
	````
	5. 各类原型方法，如Array.isArray()，Object.is()等等
	6. 通过prototype 判断是谁的子集