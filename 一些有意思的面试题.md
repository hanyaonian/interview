- 事件循环是 JS 线程处理的还是浏览器处理的？

  - 浏览器处理的。在 nodejs 上又是别的事件处理机制。
    > Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现。libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
    > 浏览器中，引用 wiki：“Event Loop 是一个程序结构，用于等待和发送消息和事件”。有一个专门负责和主线程与其他进程的通信（I/O，请求），event loop 线程。

- 当前任务队列都为空，会怎么做

  - 啥也不干（idle），等到下个任务出现

- 浏览器里有一些 js 脚本（a、b、c、d 等顺序排列），一些 css 样式表，问加载执行顺序的相关问题。

  - 如果没有加 defer，async，都是按顺序进行加载、执行，上一个没加载前是不会加载下一个的；且 js 与 css 未加载完不会进行页面渲染。css 放头部，js 放尾部可以最快的渲染出页面内容。（红宝书第二章）

- ['1', '2', '3'].map(parseInt) what & why ?

  - parseInt: 第一个参数是数字字符，第二个参数 radix 是表示进制；map func 的第一个参数是 value，第二个参数是 index。因此执行过程实际上是 1 0 进制，2 1 进制， 3 2 进制。超了进制所以是 NaN。MDN 对 parseInt 第二个参数的解释：从 2 到 36，表示字符串的基数。
    如果 radix 是 undefined、0 或未指定的，JavaScript 会假定以下情况： 1. 如果输入的 string 以 "0x"或 "0x"（一个 0，后面是小写或大写的 X）开头，那么 radix 被假定为 16，字符串的其余部分被当做十六进制数去解析。 2. 如果输入的 string 以 "0"（0）开头， radix 被假定为 8（八进制）或 10（十进制）。具体选择哪一个 radix 取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。 3. 如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。 4. 如果第一个字符不能转换为数字，parseInt 会返回 NaN。

- 列表组件中写 key，其作用是什么(看过源码，忘了。。。)？

  - 文档内说明：不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。key 不正确出现过什么问题：做 vrs 的时候，重复下单同一个商品的 key 一致，ui 渲染出现紊乱，因为识别 key 相同导致 ui 未更新，实际上内容是有更新的。
  - https://juejin.cn/post/6844904113587634184

- tcp3 次握手能带些什么其他东西

  - (zhihu)TCP 标准规定，第三次握手的报文，可以携带数据。因为此时客户端已经处于 established 状态了。假设第三次握手的报文的 seq 是 x+1，如果有携带数据，下次客户端发送的报文，seq=服务器发回的 ACK 号。如果没有携带数据，那么第三次握手的报文不消耗 seq。下次客户端发送的报文，seq 序列号还是和第三次握手的报文的 seq 一样，为 x+1。这是因为，seq 和报文中的数据在整条数据流流中的位置是一一对应的。如果报文没有携带数据，那么 seq 当然也不会更新。[图](http://d3ojx0qwvsjea2.cloudfront.net/wp-content/uploads/2016/12/24160105/Three-way-Handshake-ex2.png)

- response header 里浏览器可以获取到的信息：
